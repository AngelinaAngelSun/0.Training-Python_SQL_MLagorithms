
-- В данном блокноте содержатся материалы (шаблоны) по созданию таблиц, добавлению новых данных, установке индексов, первичных/внешних ключей и тд.

-- SQL-запросы на создание таблиц для разных баз данных (MySQL, PostgreSQL, MS SQLServer, Oracle, SQLite):


-- MySQL

	CREATE TABLE products (
		id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
		name VARCHAR(50),
		count integer,
		price DECIMAL(10,2),
		country VARCHAR(2)
	);
	INSERT INTO products (name, count, price, country) VALUES 
		('Телевизор', 3, 43200.00, 'RU'),
		('Микроволновая печь', 4, 3200.00, 'UA'),
		('Холодильник', 3, 12000.00, 'RU'),
		('Роутер', 1, 1340.00, 'US'),
		('Компьютер', 0, 26150.00, 'US'),
		('Холодильник 2', 2, 14390.00, 'BL'),
		('Чайник', 8, 1200.00, 'RU'),
		('Дрон', 1, 45990.00, 'CH'),
		('Вентилятор', 3, 3000.00, 'RU');



-- PostgreSQL

	CREATE TABLE products (
		id BIGSERIAL NOT NULL PRIMARY KEY,
		name character varying(50),
		count integer,
		price numeric(10,2),
		country character varying(2)
	);
	INSERT INTO products (name, count, price, country) VALUES 
		('Телевизор', 3, 43200.00, 'RU'),
		('Микроволновая печь', 4, 3200.00, 'UA'),
		('Холодильник', 3, 12000.00, 'RU'),
		('Роутер', 1, 1340.00, 'US'),
		('Компьютер', 0, 26150.00, 'US'),
		('Холодильник 2', 2, 14390.00, 'BL'),
		('Чайник', 8, 1200.00, 'RU'),
		('Дрон', 1, 45990.00, 'CH'),
		('Вентилятор', 3, 3000.00, 'RU');



-- MS SQLServer

	CREATE TABLE products (
		id INT IDENTITY CONSTRAINT PK_products PRIMARY KEY CLUSTERED,
		name VARCHAR(50) NOT NULL DEFAULT '',
		"count" INT NOT NULL,
		price DECIMAL(10, 2) NOT NULL,
		country VARCHAR(2) NOT NULL DEFAULT ''
	)
	INSERT INTO products (name, "count", price, country) VALUES 
		('Телевизор', 3, 43200.00, 'RU'),
		('Микроволновая печь', 4, 3200.00, 'UA'),
		('Холодильник', 3, 12000.00, 'RU'),
		('Роутер', 1, 1340.00, 'US'),
		('Компьютер', 0, 26150.00, 'US'),
		('Холодильник 2', 2, 14390.00, 'BL'),
		('Чайник', 8, 1200.00, 'RU'),
		('Дрон', 1, 45990.00, 'CH'),
		('Вентилятор', 3, 3000.00, 'RU');



-- Oracle

	CREATE TABLE products (
		id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
		name character varying(50),
		count integer,
		price numeric(10,2),
		country character varying(2)
	);
	INSERT INTO products (name, count, price, country) VALUES 
		('Телевизор', 3, 43200.00, 'RU'),
		('Микроволновая печь', 4, 3200.00, 'UA'),
		('Холодильник', 3, 12000.00, 'RU'),
		('Роутер', 1, 1340.00, 'US'),
		('Компьютер', 0, 26150.00, 'US'),
		('Холодильник 2', 2, 14390.00, 'BL'),
		('Чайник', 8, 1200.00, 'RU'),
		('Дрон', 1, 45990.00, 'CH'),
		('Вентилятор', 3, 3000.00, 'RU');



-- SQLite

	CREATE TABLE products (
		id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
		name VARCHAR(50),
		count integer,
		price DECIMAL(10,2),
		country VARCHAR(2)
	);
	INSERT INTO products (name, count, price, country) VALUES 
		('Телевизор', 3, 43200.00, 'RU'),
		('Микроволновая печь', 4, 3200.00, 'UA'),
		('Холодильник', 3, 12000.00, 'RU'),
		('Роутер', 1, 1340.00, 'US'),
		('Компьютер', 0, 26150.00, 'US'),
		('Холодильник 2', 2, 14390.00, 'BL'),
		('Чайник', 8, 1200.00, 'RU'),
		('Дрон', 1, 45990.00, 'CH'),
		('Вентилятор', 3, 3000.00, 'RU');



MySQL
ОСНОВНЫЕ ТИПЫ ДАННЫХ 
Документация MySQL https://dev.mysql.com/doc/
Справочное руководство по MySQL http://www.mysql.ru/docs/man/Reference.html
MySql материалы https://oracleplsql.ru/mysql-manual.html
Документация (Диапазоны целых чисел https://dev.mysql.com/doc/refman/5.7/en/integer-types.html)

INT  - Целочисленный тип данных (от integer), может хранить целые числа от -2_147_483_648 до 2_147_483_647. Для одного значения INT выделяется 4 байта.
TINYINT  - Целочисленный тип данных в диапозоне от -128 до 127. Для одного значения TINYINT выделяется 1 байт. Диапозон UNSIGNED до 255.
SMALLINT  - Целочисленный тип данных в диапозоне от -32768 до 32767. Для одного значения SMALLINT выделяется 2 байта. Диапозон UNSIGNED до 65535.
MEDIUMINT  - Целочисленный тип данных в диапозоне от -8388608 до 8388607. Для одного значения MEDIUMINT выделяется 3 байта. Диапозон UNSIGNED до 16777215.
BIGINT  -  Целочисленный тип данных в диапозоне от -2^63 до 2^63-1. Для одного значения BIGINT выделяется 8 байтов. Диапозон UNSIGNED о 2^64-1.
Ключевое слово UNSIGNED делает числовой диапазон беззнаковым.

BOOL \ BOLEAN - Логический тип данных (True \ False). Фактически TINYINT (1\0).

FLOAT  - Вещественный тип данных, может хранить числа с плавающей точкой от +-1.17х10^-39 до +-3.40х10^38.
DOUBLE  - Вещественный тип данных. Служит для хранения чисел с повышенной точностью. Диапазон: +-2.22х10^-308 до +-1.79х10^308
DECIMAL  - Вещественный тип данных. Служит для хранения чисел с фиксированной точностью, широко применяется для хранения финансовых данных. 

VARCHAR(length)  - Строковый тип данных фиксированной длины. В скобках указываем максимальную длину строки. Max диапазон до 65535 знаков.
TEXT  - Строковый тип для текстов большого размера нефиксирвоанной длины. Максимальный диапазон до 65535 знаков.
MEDIUMTEXT  - Строковый тип для текстов большого размера нефиксирвоанной длины. Максимальный диапазон до 16_777_215 знаков.
LONGTEXT  - Строковый тип для текстов большого размера нефиксирвоанной длины. Максимальный диапазон до 4_294_967_295 знаков.

DATE  - Календарный тип данных. Дата в диапазоне от 1000-01-01 до 9999-12-31. 
TIME  - Тип данных для хранения времени (час, мин, сек, мили-, микросек). 
DATETIME  - Календарный тип данных. Дата в диапазоне от 1000-01-01 до 9999-12-31. Хранит дату и время (час, мин, сек, мили- и микросек.).
			DATETIME(3) - для отображения милисекунд, DATETIME(6) для отображения микросекунд.

ENUM  - Хранит возможные допустимые знчения. При поиске или сортировке можно выбрать только одно из представленных.
SET - Хранит возможные допустимые знчения. При поиске или сортировке можно выбрать одно или несколько значений из представленных (find in set('value', column_name)).

BLOB  - Тип данных для хранения больших двоичных объектов (изображение, звук и т.д.). 
Однако не рекомендуется хранить в базе данных большие двоичные данные. 
Для хранения файлов лучше использовать файловую систему, в таблице держать только путь до файла.  
Так в базе данных хранится минимальная и удобная для обработки информация, а на жестком диске сам файл. 


СОЗДАНИЕ ТАБЛИЦЫ И ДОБАВЛЕНИЕ ДАННЫХ

	DROP TABLE IF EXISTS products;     
	CREATE TABLE products 
	   (
		id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,        
		name VARCHAR(255) NULL,            -- другие возможные значения: TEXT, MEDIUMTEXT, LONGTEXT
		product_count INTEGER NULL,        -- другие возможные значения: TINYINT, INT, MEDIUMINT, BIGINT
		price INTEGER NULL                 -- денежные форматы: DECIMAL, DOUBLE 
		  );
	INSERT INTO products (name, product_count, price)
	VALUES
		('Стиральная машина', 5, 10000),
		('Холодильник', 0, 10000),
		('Микроволновка', 3, 4000),
		('Пылесос', 2, 4500),

	

СОЗДАНИЕ ТАБЛИЦЫ С УНИКАЛЬНЫМ КЛЮЧОМ ПО ДВУМ КОЛОНКАМ И ПОИСКОВЫМИ ИНДЕКСАМИ
	
	CREATE TABLE passports 
								(
									id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, 
									user_id INT UNSIGNED NOT NULL, 
									series VARCHAR(4) NOT NULL, 
									number VARCHAR(6) NOT NULL, 
									state ENUM('active', 'expired') NOT NULL DEFAULT 'active',                            
									UNIQUE KEY passport(series, number),
									INDEX series(series),
									INDEX number(number)
									);
	
	
		
ДОБАВЛЕНИЕ ПРОСТОГО ПОИСКОВОГО ИНДЕКСА В УЖЕ СУЩЕСТВУЮЩУЮ ТАБЛИЦУ
	
	CREATE INDEX marks_index ON cars(mark);	
	
	
	
ДОБАВЛЕНИЕ УНИКАЛЬНОГО ИНДЕКСА В УЖЕ СУЩЕСТВУЮЩУЮ ТАБЛИЦУ
(Если таблица уже заполнена данными, то перед добавлением уникального индекса необходимо убедиться, что поле, для которого мы создаем такой индекс, не содержит дублей)

	CREATE UNIQUE INDEX email ON users(email);	
	
	
	
УДАЛЕНИЕ ИНДЕКСА

	DROP INDEX email ON users;



ИЗМЕНЕНИЕ ДАННЫХ В СТОЛБЦЕ

	UPDATE users 
	SET first_name = 'Дмитрий'
	WHERE id = 7;

	UPDATE films 
	SET rating = (kinopoisk + imdb) / 2;
	
	

УДАЛЕНИЕ НАБЛЮДЕНИЙ ИЗ СТОЛБЦА

	DELETE FROM orders 
	WHERE id in (3, 4, 7);
	

	
ДОБАВЛЕНИЕ И УДАЛЕНИЕ СТОЛБЦОВ ИЗ УЖЕ СОЗДАННОЙ ТАБЛИЦЫ
(При создании столбца к существующей таблицы важно использовать значение по умолчанию, ведь столбец прибавляется к талице, в которой уже есть записи)

	ALTER TABLE users
	ADD COLUMN birthday DATE NULL DEFAULT NULL 


	ALTER TABLE users
	DROP COLUMN birthday
	


ИЗМЕНЕНИЕ ТИПА / НАЗВАНИЯ СТОЛБЦА

	ALTER TABLE users 
	MODIFY first_name VARCHAR(50) NOT NULL DEFAULT '';     -- изменение типа столбца
	
	
	ALTER TABLE products
	CHANGE nmae name VARCHAR(50) NULL DEFAULT NULL;        -- изменение имени (и типа столбца)
	
	
	
ИЗМЕНЕНИЕ НАЗВАНИЯ ТАБЛИЦЫ

	RENAME user to users;
	RENAME user to users, log to logs;
	
	
	
ПОИСК ТЕКСТА

	SELECT *
	FROM users
	WHERE first_name = 'Наталья';             -- В MySQL найдет значения без учета регистра 'Наталья', 'наталья', 'нАталья'  (В PostreSQL '=' найдет только точное соответствие)
	
	
	SELECT *
	FROM users
	WHERE first_name LIKE 'Наталья';          -- (MySQL) Также как и в предыдущем запросе найдет значения 'Наталья', 'наталья', 'нАталья' без учета регистра
	
	
	SELECT *
	FROM users
	WHERE first_name LIKE BINARY 'Наталья';   -- (MySQL) LIKE BINARY найдет только точное соответствие с учетом регистра 'Наталья' 



ПОИСК ТЕКСТА. ИСПОЛЬЗОВАНИЕ СПЕЦСИМВОЛОВ % _   ('%' - любое кол-во символов; '_' один сивол)

	SELECT *
	FROM users
	WHERE first_name LIKE 'Н%';              -- (MySQL) Найдет все значения с начальной буквой 'Н' и любым кол-вом символов или с отсутствием знаков после этой буквы
	
	
	SELECT *
	FROM users
	WHERE phone LIKE '89____';               -- (MySQL) Найдет все шестизначные номера, начинающиеся с 89. Шаблон '_' обозначает один знак
	

ПОЛНОТЕКСТОВЫЙ ПОИСК
СОЗДАНИЕ ПОЛНОТЕКСТОВОГО ИНДЕКСА И ПОИСК

	CREATE FULLTEXT INDEX idx_name ON products(name);
	
	SELECT *
	FROM products
	WHERE MATCH(name) AGAINST ('микроволновая печь'); 					   -- Конструкцтя ищет не фразу 'микроволновая печь', а слова по отдельности, как в LIKE-запросе, 
																		   -- и сортирует по релевантности
	 
	SELECT *
	FROM products                                                          -- Переключение в логический режим (IN BOOLEAN MODE) для более точных и гибких запросов
	WHERE MATCH(name) AGAINST ('+микроволновая +печь' IN BOOLEAN MODE);    -- '+' - слова обязательно должны быть в выдаче (не обязательно в том же порядке)
	
	
	SELECT *
	FROM products                                                        
	WHERE MATCH(name) AGAINST ('-микроволновая +печь' IN BOOLEAN MODE);    -- '-' - слово не должно присутствовать в поле поиска 
	
	
	SELECT *
	FROM products                                                        
	WHERE MATCH(name) AGAINST ('~микроволновая +печь' IN BOOLEAN MODE);    -- '~' - не исключает слово, но обесценивает его значимость (слово с ~ окажется в конце выдачи)

	
	
СТРОКОВЫЕ ФУНКЦИИ
Строковых функций более 50. Документация:  
  https://oracleplsql.ru/string-char-functions-mysql.html
  http://www.mysql.ru/docs/man/String_functions.html
  https://dev.mysql.com/doc/refman/8.0/en/string-functions.html

	SELECT  id,                                          -- Соединение фамилии и инициалов при помощи строковых функций (напр.: Иванов А.)
			first_name,
			CHAR_LENGTH(first_name) as length,
			CONCAT(TRIM(last_name), ' ', UPPER(LEFT(first_name, 1)), '.') as first_name
	FROM users
	WHERE CHAR_LENGTH(first_name) > 4;
					
	
	UPDATE products                                      -- Обновление столбца name, удаление пробелов в начале и в конце названий продуктов 
	SET name = TRIM(name);
	
	
	UPDATE domains
	SET domain = TRIM(TRAILING '.' FROM domain);         -- Обновление столбца domains, чтобы доменные имена не заканчивались точкой
	
	

ФУНКЦИИ ДАТЫ
Документация: 
https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html
http://www.mysql.ru/docs/man/Date_and_time_functions.html
https://oracleplsql.ru/date-time-functions-mysql.html


	SELECT *,                                            -- Разложение даты рождения на части и вывод пользователей, у которых сегодня день рождения
			YEAR(birthday) as year,                      -- Из даты можно получить YEAR, MONTH, DAY, WEEK, DAYNAME, MONTHNAME, MINUTE, SECOND, HOUR
			MONTH(birthday) as month,                                
			DAY(birthday) as day,                                  
	FROM users
	WHERE MONTH(birthday) = MONTH(now()) and DAY(birthday) = DAY(now());
	
	

	SELECT *                                             -- Пользователи, которые зарегистрировались за последнюю неделю (NOW() - INTERVAL 7 DAY)                                  
	FROM users
	WHERE date_joined > NOW() - INTERVAL 7 DAY;
	


	SELECT  *,                                       	 -- Дата окончания trial-периода (date_joined + INTERVAL 1 MONTH)
			date_joined + INTERVAL 1 MONTH as trial_end
	FROM users



	SELECT  *,                                       	 -- Изменение формата выдачи даты (DATE_FORMAT)
			DATE_FORMAT(date_joined + INTERVAL 1 MONTH, '%d.%m.%Y %H:%i') as trial_end
	FROM users
	
	
ФУНКЦИИ АГРЕГАЦИИ
Документация:	
https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html
https://function-x.ru/sql_sum_min_max_avg_count.html